{
  "fragment.glsl": "uniform float time;\nuniform vec3 baseFirst;\nuniform vec3 baseSecond;\nuniform vec3 accent;\nuniform float progress;\nuniform sampler2D texture1;\nuniform vec4 resolution;\nvarying vec2 vUv;\nvarying vec3 vPosition;\nfloat PI = 3.141592653589793238;\n\n// NOISE\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\nfloat lines(vec2 uv, float offset){\n\treturn smoothstep(\n\t\t0., 0.5 + offset*0.5,\n\t\t0.5*abs((sin(uv.x*35.) + offset*2.))\n\t);\n}\n\n\n\nmat2 rotate2D(float angle){\n\treturn mat2(\n\t\tcos(angle),-sin(angle),\n\t\tsin(angle),cos(angle)\n\t);\n}\n\nvoid main()\t{\n\n\t// vec3 baseFirst =  vec3(120./255., 158./255., 113./255.);\n\t// vec3 accent =  vec3(0., 0., 0.);\n\t// vec3 baseSecond =  vec3(224./255., 148./255., 66./255.);\n\tfloat n = noise(vPosition +time);\n\t// vec3 color1 = vec3(1.,0.,0.);\n\t// vec3 color2 = vec3(0.,1.,0.);\n\t// vec3 color3 = vec3(0.,0.,1.);\n\n\tvec2 baseUV = rotate2D(n)*vPosition.xy*0.1;\n\tfloat basePattern = lines(baseUV, 0.5);\n\tfloat secondPattern = lines(baseUV, 0.1);\n\n\tvec3 baseColor = mix(baseSecond,baseFirst,basePattern);\n\tvec3 secondBaseColor = mix(baseColor,accent,secondPattern);\n\n\n\t// vec2 newUV = (vUv - vec2(0.5))*resolution.zw + vec2(0.5);\n\tgl_FragColor = vec4(vec3(secondBaseColor),3.);\n}",
  "fragment1.glsl": "\n\nuniform samplerCube tCube;\nvarying vec3 vPosition;\n\nvarying vec3 vReflect;\nvarying vec3 vRefract[3];\nvarying float vReflectionFactor;\n\nvoid main() {\n\n\tvec4 reflectedColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );\n\tvec4 refractedColor = vec4( 1.0 );\n\n\trefractedColor.r = textureCube( tCube, vec3( vRefract[0].x, vRefract[0].yz ) ).r;\n\trefractedColor.g = textureCube( tCube, vec3( vRefract[1].x, vRefract[1].yz ) ).g;\n\trefractedColor.b = textureCube( tCube, vec3( vRefract[2].x, vRefract[2].yz ) ).b;\n\n\tgl_FragColor = mix( refractedColor, reflectedColor, clamp( vReflectionFactor, 0.0, 1.0 ) );\n\n\n\t// gl_FragColor = vec4(vec3(vReflectionFactor),1.);\n\t// gl_FragColor = reflectedColor;\n\n\n}",
  "vertex.glsl": "uniform float time;\nvarying vec2 vUv;\nvarying vec3 vPosition;\nuniform vec2 pixels;\nfloat PI = 3.141592653589793238;\nvoid main() {\n  vUv = uv;\n  vPosition = position;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
  "vertex1.glsl": "uniform float time;\nvarying vec2 vUv;\nvarying vec3 vPosition;\nuniform vec2 pixels;\nfloat PI = 3.141592653589793238;\n\n\nvarying vec3 vReflect;\nvarying vec3 vRefract[3];\nvarying float vReflectionFactor;\n\n\nuniform float mRefractionRatio;\nuniform float mFresnelBias ;\nuniform float mFresnelScale;\nuniform float mFresnelPower;\n\nvoid main() {\n\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\n  vec3 worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );\n\n  vec3 I = worldPosition.xyz - cameraPosition;\n\n  vReflect = reflect( I, worldNormal );\n  vRefract[0] = refract( normalize( I ), worldNormal, mRefractionRatio );\n  vRefract[1] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.99 );\n  vRefract[2] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.98 );\n  vReflectionFactor = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( I ), worldNormal ), mFresnelPower );\n\n  gl_Position = projectionMatrix * mvPosition;\n\n}"
}